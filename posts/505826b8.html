<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis进阶 | LinkaSage' Blog</title><meta name="author" content="LinkaSage"><meta name="copyright" content="LinkaSage"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="1. AOF持久化实践1.修改配置文件修改 redis.conf 文件，在其中编写如下配置信息 123appendonly yes # 启动AOF持久化机制appendfsync everysec # 设置了持久化的策略，即持久化的频率是——每秒dir .&#x2F; # 设置了持久化文件的保存路径  这里没有通过 appendfilename 参数设置持久化文件的名字，所以会选用默认的 appendonl">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis进阶">
<meta property="og:url" content="https://linkasage.github.io/posts/505826b8.html">
<meta property="og:site_name" content="LinkaSage&#39; Blog">
<meta property="og:description" content="1. AOF持久化实践1.修改配置文件修改 redis.conf 文件，在其中编写如下配置信息 123appendonly yes # 启动AOF持久化机制appendfsync everysec # 设置了持久化的策略，即持久化的频率是——每秒dir .&#x2F; # 设置了持久化文件的保存路径  这里没有通过 appendfilename 参数设置持久化文件的名字，所以会选用默认的 appendonl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wwww.lvmoo.com/1195.love/3398019585_hudf00fdeabc994d23ae3b1aa2b480a234_181774_1024x0_resize_q75_box.jpg">
<meta property="article:published_time" content="2022-12-18T03:14:44.000Z">
<meta property="article:modified_time" content="2024-04-07T13:07:01.460Z">
<meta property="article:author" content="LinkaSage">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="Redis进阶">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wwww.lvmoo.com/1195.love/3398019585_hudf00fdeabc994d23ae3b1aa2b480a234_181774_1024x0_resize_q75_box.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://linkasage.github.io/posts/505826b8.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis进阶',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-07 21:07:01'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="LinkaSage' Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/weichao-here/ChartBed/img/istj-logistician-s3-v1-male.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://wwww.lvmoo.com/1195.love/3398019585_hudf00fdeabc994d23ae3b1aa2b480a234_181774_1024x0_resize_q75_box.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="LinkaSage' Blog"><span class="site-name">LinkaSage' Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 类别</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis进阶</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-18T03:14:44.000Z" title="发表于 2022-12-18 11:14:44">2022-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-07T13:07:01.460Z" title="更新于 2024-04-07 21:07:01">2024-04-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis进阶"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-AOF持久化实践"><a href="#1-AOF持久化实践" class="headerlink" title="1. AOF持久化实践"></a>1. AOF持久化实践</h1><h2 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1.修改配置文件"></a>1.修改配置文件</h2><p>修改 redis.conf 文件，在其中编写如下配置信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes # 启动AOF持久化机制</span><br><span class="line">appendfsync everysec # 设置了持久化的策略，即持久化的频率是——每秒</span><br><span class="line">dir ./ # 设置了持久化文件的保存路径</span><br></pre></td></tr></table></figure>

<p>这里没有通过 appendfilename 参数设置持久化文件的名字，所以会选用默认的 appendonly.aof 文件名</p>
<h2 id="2-重新启动-redis"><a href="#2-重新启动-redis" class="headerlink" title="2.重新启动 redis"></a>2.重新启动 redis</h2><p>检查 redis 是否是启动中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure>

<p>关闭 redis</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 123456 shutdown</span><br></pre></td></tr></table></figure>

<p>重启 redis</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到 redis.config 所在目录</span></span><br><span class="line">/opt/server/redis-6.2.7</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载配置文件启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>

<h2 id="3-操作-redis"><a href="#3-操作-redis" class="headerlink" title="3.操作 redis"></a>3.操作 redis</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set name zhangsan</span><br><span class="line">set age 22</span><br><span class="line">get name</span><br></pre></td></tr></table></figure>

<p>此时 AOF 持久化机制已经生效，每秒会同步持久化文件，而且之前也运行了若干写命令，所以可以观察 AOF 持久化文件里的内容。</p>
<p>查看当前目录下（允许 redis-server 所在目录）appendonly.aof 文件中的内容</p>
<p><img src="https://i0.hdslb.com/bfs/album/8a2582d8ab81e39127bd5d583ef70f4ef883db56.png" alt="image-20221124161730684"></p>
<p>第一条命令是 select 0，表示开启 0 号数据库，能看到第二条和第三条 set 命令，get name 命令是读命令，所以不会写入持久化文件</p>
<h2 id="4-模拟数据恢复"><a href="#4-模拟数据恢复" class="headerlink" title="4.模拟数据恢复"></a>4.模拟数据恢复</h2><p>flushall 命令能清空 Redis 的所有内存数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushall</span><br></pre></td></tr></table></figure>

<p>注意 flushall 命令也会记录到 aof 文件中，打开 AOF 文件，删除最后一行的 flushall 命令，如果不删除，在进行数据恢复时还会运行这条命令，从而把数据清空</p>
<p>关闭 redis 服务，并重启</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 123456 shutdown</span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>

<p>观察数据是否被还原</p>
<h1 id="2-RDB-持久化实践"><a href="#2-RDB-持久化实践" class="headerlink" title="2. RDB 持久化实践"></a>2. RDB 持久化实践</h1><h2 id="1-修改配置文件-1"><a href="#1-修改配置文件-1" class="headerlink" title="1.修改配置文件"></a>1.修改配置文件</h2><p>在 Redis 的 redis.conf 配置文件里，可以通过 save 参数配置生成 RDB 快照的条件，具体代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 600 1 		# 表示当在600秒内有1个或1个以上的键被修改时就会生成快照</span><br><span class="line">save 300 100	# ...300秒...大于或等于100个.....</span><br><span class="line">save 60 1000	# ...60秒...大于或等于1000个.....</span><br></pre></td></tr></table></figure>

<p>注意，这三个条件是”或“的关系，即只要有一个条件被满足，就会生成快照。从中能看出，RDB 持久化文件只是当条件满足后生成快照，所以无法即时保存当前状态的内存数据。也就是说，通过RDB恢复数据时，会丢失上次生成快照后更新的数据。</p>
<p>同时，在 redis.conf 里加上如下两条描述快照文件名的配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbfilename redis.rdb</span><br></pre></td></tr></table></figure>

<h2 id="2-重新启动-redis-1"><a href="#2-重新启动-redis-1" class="headerlink" title="2.重新启动 redis"></a>2.重新启动 redis</h2><p>检查 redis 是否启动中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure>

<p>关闭 redis</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -a 123456 shutdown</span><br></pre></td></tr></table></figure>

<p>重启 redis</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到 redis.config 所在目录</span></span><br><span class="line">/opt/server/redis-6.2.7</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载配置文件启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>

<h2 id="3-操作redis"><a href="#3-操作redis" class="headerlink" title="3.操作redis"></a>3.操作redis</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set name lisi</span><br></pre></td></tr></table></figure>

<p>此时满足”600秒里有一个或一个以上键被修改“这个条件，所以能看到 RDB 持久化文件 redis.rdb，不过 RDB 持久化文件是二进制格式，所以用记事本打开后看到的是乱码。</p>
<h2 id="4-用快照文件恢复数据"><a href="#4-用快照文件恢复数据" class="headerlink" title="4.用快照文件恢复数据"></a>4.用快照文件恢复数据</h2><p>和 AOF 持久化方式一样，通过 RDB 的快照文件可以恢复数据，如果 redis 数据出现了丢失，在去启动时会根据快照文件恢复数据</p>
<h1 id="3-使用-docker-安装-redis"><a href="#3-使用-docker-安装-redis" class="headerlink" title="3. 使用 docker 安装 redis"></a>3. 使用 docker 安装 redis</h1><p>用 docker pull 下载最新版的 Redis 镜像，也可以用 ”docker pull redis:标签“命令下载指定版本的 Redis，如果不指定，就会用默认的标签 latest 去下载最新版本的 Redis 镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br></pre></td></tr></table></figure>

<p>docker images，表示已经成功下载了最新版本的 Redis 镜像</p>
<p><img src="https://i0.hdslb.com/bfs/album/939d1e3be9866360d82b04111f971c49027e2263.png" alt="image-20221124193702394"></p>
<h2 id="3-1-运行-Redis-容器"><a href="#3-1-运行-Redis-容器" class="headerlink" title="3.1 运行 Redis 容器"></a>3.1 运行 Redis 容器</h2><p>随后可以用如下的 run 命令来运行 Redis 容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-test1 -p 6379:6379 redis:5.0.14</span><br></pre></td></tr></table></figure>

<p>这里的 <code>-it</code> 表示在终端交互式操作，d 表示在后台运行；通过 <code>--name</code> 指定该容器的名字；通过 <code>-p</code> 参数指定容器的 6379 端口映射到宿主机（即运行 Docker 的机器）6379 端口，这样在容器外部就能以宿主机 <code>ip:6379</code> 的方式访问 Redis 服务；最后的 <code>redis:5.0.14</code> 参数指定根据该镜像启动容器</p>
<p>运行完上述 <code>run 命令</code>后在执行 <code>docker ps</code> 命令：</p>
<p><img src="https://i0.hdslb.com/bfs/album/2dcea5f9db4d5731b87d50c541254d9883a87697.png" alt="image-20221124194538385"></p>
<p>从中可以看到，名为 redis-test1的容器处于 Up状态，并且是通过 6379 端口对外提供服务的。</p>
<h2 id="3-2-查看启动日志"><a href="#3-2-查看启动日志" class="headerlink" title="3.2 查看启动日志"></a>3.2 查看启动日志</h2><p>如果直接在 Linux 等环境上启动 Redis 服务器，就能直接看到启动后的效果。这里由于通过 Docker 容器启动 Redis 服务，因此在用 <code>docker run</code> 命令启动 Redis 容器后，可以通过如下的 <code>docker log</code> 命令来观察启动的效果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs redis-test1</span><br></pre></td></tr></table></figure>

<p>上述 docker logs 命令用来输出容器启动时的日志，redis-test1 则表示待查看日志的容器名。如果 Docker 容器中的Redis 正确启动，就能看到如图效果：</p>
<p><img src="https://i0.hdslb.com/bfs/album/cb0429542b923a9198b03c1f988fd6c00525c9e3.png" alt="image-20221124200713567"></p>
<h2 id="3-3-进入Redis容器"><a href="#3-3-进入Redis容器" class="headerlink" title="3.3 进入Redis容器"></a>3.3 进入Redis容器</h2><p>通过 run 命令能在后台启动 Redis 容器，此时可以通过如下的 <code>exec</code> 命令进入 Redis 容器，进而执行 Redis 的相关操作：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-test1 /bin/bash</span><br></pre></td></tr></table></figure>

<p><code>docker exec</code> 表示在运行的容器中执行命令，其中 redis-test1 参数表示在哪个容器里执行命令，-it 表示以终端交互的方式执行命令，<code>/bin/bash</code> 表示需要指定的命令</p>
<p>执行上述 exec 命令后，就能看到如图所示的效果，说明已经进入了名为 redis-test1 的容器</p>
<p><img src="https://i0.hdslb.com/bfs/album/2294fb2d1146abf2bc377bdc979ee2dc9f392347.png" alt="image-20221124201651774"></p>
<p>可以通过输入 <code>redis-cli</code> 命令连接容器里的 Redis 服务器，随后可以通过 <code>set val 1</code> 命令创建一个值为1的val变量，创建后再通过 <code>get val</code> 来获取val变量的值：</p>
<p><img src="https://i0.hdslb.com/bfs/album/c39753bcfb2816827af8dac922aba93dc21993d7.png" alt="image-20221124202116628"></p>
<p>当然也可以通过其他客户端工具访问。只要能成功地运行 Redis 相关命令并看到对应地结果，就说明基于 Docker 的 Redis 成功地安装到本机里了</p>
<h2 id="3-4-退出-Redis-容器"><a href="#3-4-退出-Redis-容器" class="headerlink" title="3.4 退出 Redis 容器"></a>3.4 退出 Redis 容器</h2><p>随后如果想退到Windows命令行，就需要连续两次输入exit，其中第一个exit命令能退出用 redis-cli 进入地 redis 运行窗口，第二个exit命令能退出因 docker exec命令而进入地 redis 容器。</p>
<p>可以通过 docker stop redis-test1命令停止该容器，其实 redis-test1 是待停止的容器名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop redis-test1</span><br></pre></td></tr></table></figure>

<p>要再次启动该容器，可以使用</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker start redis-test1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或</span></span><br><span class="line">docker restart redis-test1</span><br></pre></td></tr></table></figure>

<p>这两个命令的差别是，<code>docker start **</code> 会挂载容器所关联的文件系统，而 <code>docker restart **</code> 不会</p>
<h2 id="3-5-启动时加载配置文件"><a href="#3-5-启动时加载配置文件" class="headerlink" title="3.5 启动时加载配置文件"></a>3.5 启动时加载配置文件</h2><p>通过 docker 命令，用 Redis 的镜像创建容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis2 -v /opt/server/redis-6.2.7/redis.conf:/redisConfig/redis.conf -p 6379:6379 redis:5.0.14 redis-server /redisConfig/redis.conf</span><br></pre></td></tr></table></figure>

<p>通过 <code>--name</code> 的方式指定该容器的名字为 <code>redis2</code> ，用 <code>-v</code> 指定本机和 Docker 虚拟机内目录和文件的映射关系，具体是把 &#x2F;opt&#x2F;server&#x2F;redis-6.2.7&#x2F;redis.conf 映射成 Docker 虚拟机里的 redisConfig&#x2F;redis.conf 文件，用 <code>-p</code> 参数来指定 Docker 虚拟机的 6379 端口映射到本机的 6379 端口上，以 redis；latest 的方式指定本容器的镜像为指定版本的 redis 镜像</p>
<p>再用 redis-server &#x2F;redisConfig&#x2F;redis.conf 的方式指定启动 redisWithConfig 镜像，即用 redis-server 命令启动 Redis 服务器时需要装载对应的 redis.conf 文件</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>redis.conf 的 daemonize表示是否守护进行执行</li>
<li>docker run 命令里有一个参数 <code>-d</code> ，这个参数也是守护进程执行</li>
<li>为了防止冲突要修改 redis.conf 配置文件，把 daemonize 修改为 no</li>
</ul>
<h1 id="4-Redis集群"><a href="#4-Redis集群" class="headerlink" title="4. Redis集群"></a>4. Redis集群</h1><h2 id="1-主从复制模式集群"><a href="#1-主从复制模式集群" class="headerlink" title="1.主从复制模式集群"></a>1.主从复制模式集群</h2><h3 id="1-1-用命令搭建主从集群"><a href="#1-1-用命令搭建主从集群" class="headerlink" title="1.1 用命令搭建主从集群"></a>1.1 用命令搭建主从集群</h3><p>这里将用Docker容器来搭建一主二从模式的集群，在配置主从关系时，需要在从节点上使用slaveof命令，具体的步骤如下：</p>
<p>打开一个命令窗口，在其中运行如下命令创建一个名为redis-master的Redis容器。注意，它的端口是6379。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-master -p 6379:6379 redis:6.2.7</span><br></pre></td></tr></table></figure>

<p>新开一个命令窗口，在其中运行如下命令创建一个名为redis-slave1的容器。注意，它的端口是6380。这里是在一台电脑上运行，所以用端口号来区别<strong>一台主Redis容器</strong>和另外<strong>两台从Redis容器</strong>。在真实项目里，多台Redis会部署在不同的服务器上，所以可以都用6379端口。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-slave1 -p 6380:6380 redis:6.2.7</span><br></pre></td></tr></table></figure>

<p><img src="https://i0.hdslb.com/bfs/album/00be6933403555eddec362b12467f71cc1ea9f87.png" alt="image-20221124214604305"></p>
<p>回到包含 redis-master 容器的命令窗口，在其中运行 docker inspect redis-master命令，查看 redis-master 容器的信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect redis-master | grep IPAddress</span><br></pre></td></tr></table></figure>

<p>在其中能通过 IPAddress 项看到该容器的 IP 地址，这里是 <code>172.17.0.2</code> 。在真实项目里，Redis 服务器所在的 IP地址 是固定的，而通过Docker 容器启动的 Redis 服务器的 IP地址 是动态的，所以这里要用上述命令来获取IP地址。</p>
<p><img src="https://i0.hdslb.com/bfs/album/9973d95ca3f00343a51321aa5c9f26d5039184fc.png" alt="image-20221124214634829"></p>
<p>在 redis-master 容器的命令窗口里，运行 docker exec -it redis-master &#x2F;bin&#x2F;bash 命令，进入命令行窗口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-master /bin/bash</span><br></pre></td></tr></table></figure>

<p>在其中用 <code>redis-cli</code> 命令进入 Redis 客户端命令行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>

<p>通过 <code>info replication</code> 命令查看当前的主从模式状态，能看到如下所示的部分结果。&#x3D;&#x3D;默认为主服务器&#x3D;&#x3D;</p>
<p><img src="https://i0.hdslb.com/bfs/album/5f5cc7f93e17939a9a197eac792b5af9ff1f23fd.png" alt="image-20221124214824360"></p>
<p>由于此时还没有通过命令行设置主从模式，因此输出结果里依然能看到当前服务器是”主服务器“，同时没有携带从服务器</p>
<p>在 redis-slave1容器的命令窗口里运行如下的 <code>slaveof</code> 命令，指定当前 Redis 服务器为从服务器。该命令的格式是 <code>slaveof IP地址端口号</code>，这里指向 <code>172.17.0.2:6379</code> 所在的主服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof 172.17.0.2 6379</span><br></pre></td></tr></table></figure>

<p>运行完该命令后，在 redis-slave1 客户端里再次运行 <code>info replication</code>，会看到如下所示的部分结果</p>
<p><img src="https://i0.hdslb.com/bfs/album/ef2ebb8fe25e3658c77e3a896a819d8b6f8aa775.png" alt="image-20221124215521366"></p>
<p>回到 redis-master 客户端里运行 <code>info replication</code>，会看到如下部分结果</p>
<p><img src="https://i0.hdslb.com/bfs/album/1ad6be0e84db40d08df8c7d2fc719f2d6dbe8fb2.png" alt="image-20221124215845993"></p>
<p>打开一个新的命令窗口，在其中运行如下命令，开启一个新的名为 redis-slave2 的Redis 容器。注意，它的端口是 6381。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-slave2 -p 6381:6381 redis:6.2.7</span><br></pre></td></tr></table></figure>

<p>随后按照 &#x3D;&#x3D;redis-slave1&#x3D;&#x3D; 的从机配置方式配置 redis-slave2。</p>
<p><img src="https://i0.hdslb.com/bfs/album/21b59cffceea8f008862bb6e5a4e3b3148ed661d.png" alt="image-20221124220516961"></p>
<p>连接完成后，回到 redis-master 容器所在的命令行窗口，运行 <code>info replication</code> 命令，此时能看到如下的部分输出，从第4行的输出里能看到当前的主服务器连接着两台从服务器</p>
<p><img src="https://i0.hdslb.com/bfs/album/238c690dc895f15307eb25e667dc44a49124a30e.png" alt="image-20221124220752010"></p>
<p>至此，配置完成一主二从模式的主从模式。</p>
<p>此时，到两太从服务器里运行 <code>get name</code> 命令，返回是空；在 redis-master容器所在的命令窗口运行 <code>set name Zhangsan</code> 后，再到两台从服务器里运行 <code>get name</code> 命令，就能看到返回值。</p>
<p><img src="https://i0.hdslb.com/bfs/album/3847e844acc53869cac4b1926079bab1f7bbd00e.png" alt="image-20221124221153240"></p>
<p><img src="https://i0.hdslb.com/bfs/album/a0a280daa8b10e5cb4d3f36775649ac2f6651363.png" alt="image-20221124221214023"></p>
<p>&#x3D;&#x3D;说明主从模式配置成功，主服务器里的数据会自动同步到各从服务器上&#x3D;&#x3D;</p>
<h3 id="1-2-通过配置搭建主从集群"><a href="#1-2-通过配置搭建主从集群" class="headerlink" title="1.2 通过配置搭建主从集群"></a>1.2 通过配置搭建主从集群</h3><p>在项目里除了可以用 <code>slaveof</code> 命令搭建主从模式的集群外，还可以用配置参数的方式来搭建，具体的步骤如下：</p>
<p>搭建主服务器 redis-master 的命令不变，并且还是用 6379 端口</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-master -p 6379:6379 redis:6.2.7</span><br></pre></td></tr></table></figure>

<p>用 <code>docker inspect redis-master</code> 命令确认该 Redis 服务武器所在容器的 IP地址仍然是 <code>172.17.0.2</code></p>
<p>在 <code>/opt/server</code> 下编写配置文件 <code>redisSlave1.conf</code> ，并在其中编写如下内容</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 6380	# 设置该Redis的端口为6380</span><br><span class="line">slaveof 172.17.0.2 6379		# 设置该Redis服务器为”从模式“，并连接到 redis-master 所在的主服务器上</span><br></pre></td></tr></table></figure>

<p>在新的命令窗口里运行如下的命令，创建名为 redis-slave1 的Redis服务器。该服务器的工作端口是 6380，并且用 redis-server 后的参数指定在启动 Redis 服务器时加载 redisSlave1.conf 配置文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-slave1 -v /opt/server/redisSlave1.conf:/redisConfig/redisSlave1.conf -p 6380:6380 redis:6.2.7 redis-server /redisConfig/redisSlave1.conf</span><br></pre></td></tr></table></figure>

<p>随后通过 <code>docker exec -it redis-slave1 /bin/bash</code> 命令进入到该容器的命令行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-slave1 /bin/bash</span><br></pre></td></tr></table></figure>

<p>由于 Redis 工作端口已经变成 6380（配置文件中指定了端口），所以需要通过 <code>redis-cli -h 127.0.0.1 -p 6380</code> 命令进入Redis客户端。在其中运行 <code>info replication</code> 命令</p>
<p><img src="https://i0.hdslb.com/bfs/album/89f6688eac2d718f7de63b9c4cfa5b2d281c7a99.png" alt="image-20221124224934063"></p>
<p>以同样的方式创建 redis-slave2，将端口绑定到 6381 即可</p>
<p><img src="https://i0.hdslb.com/bfs/album/295f7c00f0cfcab0bdd828f1cec1638e7f106ede.png" alt="image-20221124225709626"></p>
<p><img src="https://i0.hdslb.com/bfs/album/4c1a2d4b6c0257a8d8d62268b2d174ca96980a60.png" alt="image-20221124225806586"></p>
<h3 id="1-3-配置读写分离效果"><a href="#1-3-配置读写分离效果" class="headerlink" title="1.3 配置读写分离效果"></a>1.3 配置读写分离效果</h3><p>在上文里配置的 redis-slave1 和 redis-slave2 这两台从服务器里运行 <code>info replication</code> 命令，还能看到  ”slave_read_only:1“ 这项配置，说明从服务器默认是”只读“的。</p>
<p>在从机的 redis 客户端命令行里输入 <code>set val 1</code> ，会提示错误，从而进一步验证该 Redis 服务器的 ”只读“属性。</p>
<p><img src="https://i0.hdslb.com/bfs/album/554d45b43462f426d9035fe76ac606e7d023e4cc.png" alt="image-20221124230324390"></p>
<p>对于 Redis 从服务器而言，建议采用默认的”只读“配置，因为在项目里一般不会向作为数据同步目的地的”从服务器“上写数据。如果业务上确实需要，可以通过如下步骤设置”可读可写“的效果</p>
<p>在上文提到的 redisSlave2.conf 配置文件里再加入一行 ”slave-read-only no“的配置，指定该服务器可读可写。</p>
<p>如果上文提到的 redis-slave2 容器还处于活动状态，则需要先用 <code>docker stop redis-slave2</code> 停用该容器，再用 <code>docker rm redis-slave2</code> 命令删除该容器，之后可以用如下命令再次创建 redis-slave2 容器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-slave2 -v /opt/server/redisSlave2.conf:/redisConfig/redisSlave2.conf -p 6381:6381 redis:6.2.7 redis-server /redisConfig/redisSlave2.conf</span><br></pre></td></tr></table></figure>



<h3 id="1-4-用心跳机制提高主从复制的可靠性"><a href="#1-4-用心跳机制提高主从复制的可靠性" class="headerlink" title="1.4 用心跳机制提高主从复制的可靠性"></a>1.4 用心跳机制提高主从复制的可靠性</h3><p>在Redis主从复制模式里，如果主从服务器之间有数据同步的情况，那么从服务器会默认以一秒一次的频率向主服务器发送<code>REPLCONFACK命令</code>，依次来确保两者间连接通畅。这种定时交互命令确保连接的机制就叫”心跳”机制。</p>
<p>在上文开启的redis-master这个主服务器的命令行里，运行info replication命令，就能看到它从属服务器的“心跳””状况。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure>

<p><img src="https://i0.hdslb.com/bfs/album/55a21380b5cf648c0408517d126eeff1590f0774.png" alt="image-20221124231213931"></p>
<p>通过 lag 表示该从属服务器发送 REPLCONFACK ACK 命令实践，这里均是1秒，表示两台从服务器和主服务器的连接均属通畅。</p>
<p>这里大家可以想象一下，如果从服务器宕机，那么主从复制就没有意义了。对此，可以通过如下的步骤来关联心跳机制和主动复制的动作。</p>
<p>在 <code>/opt/server</code> 下新建 redisMaster.conf 文件，在其中编写如下的代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 2	# 表示实现主从复制的从服务器个数最少是2台</span><br><span class="line">min-slaves-max-lag 15	# 表示如果第1行参数指定的从服务器个数（这里是2台）的心跳延迟时间(lag值)大于15s，就不执行主从复制</span><br></pre></td></tr></table></figure>

<p>这两个条件是”或者“关系，即只要出现从服务器个数小于2，或者2太从服务器的心跳延迟大于15s，主服务器即停止主从复制的操作。</p>
<p>需要重新启动主服务器容器，加载配置文件</p>
<p>在上文开启的redis-master主服务器的命令行里，运行info replication命令，能看到表示复制数据偏移量的master_repl_offset数据这里的数据是1614，表示主服务器向从服务器发送数据的字节数。</p>
<p>同样，到redis-slave1从服务器的命令行里也能通过info replication查看该偏移量。</p>
<p>在从服务器里，该数据表示从主服务器中接收到的数据字节数，如果主从服务器中两者的数据一致，就说明主从服务器间的数据是同步的。</p>
<p>如果出现Redis问题，可以通过master_repl_offset数值来检查同步数据是否正确，由此再进一步排查问题。</p>
<h2 id="2-哨兵模式集群"><a href="#2-哨兵模式集群" class="headerlink" title="2.哨兵模式集群"></a>2.哨兵模式集群</h2><h3 id="2-1搭建哨兵模式集群"><a href="#2-1搭建哨兵模式集群" class="headerlink" title="2.1搭建哨兵模式集群"></a>2.1搭建哨兵模式集群</h3><p>通过如下的步骤，大家可以用 Docker 容器搭建基于哨兵的集群，由此可以感受到各节点的作用以及整个集群的工作方式。</p>
<p>首先按照之前 （&#x3D;&#x3D;添加连接&#x3D;&#x3D;）的方法搭建一个一主二从的 redis 集群，其中 redis-master 是主服务器，redis-slave1 和 redis-slave2 是从服务器。</p>
<p>在 <code>/opt/server</code> 目录里创建 sentine1.conf 配置文件，该配置文件会在启动哨兵节点时被读取，代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port 16379 # 指定哨兵节点的工作端口</span><br><span class="line">sentinel monitor master 172.17.0.2 6379 2 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定监控对象。master是哨兵结点为所监控服务器指定的名字，172.17.0.2和6379分别表示 redis-master 这台主服务器的ip和端口号，2表示至少需要有2台哨兵节点认可才能认定该主服务器失效。</span></span><br><span class="line">logfile &quot;sentinel1.log&quot; # 指定该哨兵节点的日志文件名</span><br></pre></td></tr></table></figure>

<p> 完成编写上述配置文件后，新开一个命令窗口，在其中运行如下的命令，新启一个名为 redis-sentine1 的 Docker 容器，并在其中启动哨兵（sentinel）节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 /opt/server/</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-sentinel1 -v /opt/server:/redisConfig:z -p 16379:16379 redis:6.2.7 redis-server /redisConfig/sentinel1.conf --sentinel</span><br></pre></td></tr></table></figure>

<p><img src="https://i0.hdslb.com/bfs/album/0b55fe8fa2ce8ef0f236fe267468caf571653b96.png" alt="image-20221125093119744"></p>
<p>通过上述命令启动一个哨兵节点后，可以通过 <code>docker exec -it redis-sentinel1 /bin/bash</code> 命令进入Docker容器里的命令行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-sentinel1 /bin/bash</span><br></pre></td></tr></table></figure>

<p>然后通过下述命令进入 Redis 客户端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 16379</span><br></pre></td></tr></table></figure>

<p>在 Redis 客户端里，查看哨兵节点的信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info sentinel</span><br></pre></td></tr></table></figure>

<p><img src="https://i0.hdslb.com/bfs/album/418ff5b240dece139c44f4da52bbb94500909995.png" alt="image-20221125094849062"></p>
<p>该哨兵节点监控的主服务器状态（status）是ok，slaves数量是2，即该主服务器有2个从服务器，这个之前的配置情况是一致的。</p>
<p>创建 sentinel2.conf 配置文件，其中的代码如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">port 16380</span><br><span class="line">sentinel monitor master 172.17.0.2 6379 2</span><br><span class="line">logfile &quot;sentinel2.log&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 /opt/server/sentinel2.conf</span><br></pre></td></tr></table></figure>

<p>该配置文件和哨兵节点 redis-sentinel1所用到的很相似，只不过是把端口改为 16380，同时更改了日志文件名</p>
<p>随后开启一个命令窗口，在其中创建一个哨兵节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-sentinel2 -v /opt/server:/redisConfig:z -p 16380:16380 redis:6.2.7 redis-server /redisConfig/sentinel2.conf --sentinel</span><br></pre></td></tr></table></figure>

<p>随后进入该哨兵节点的命令行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-sentinel2 /bin/bash</span><br></pre></td></tr></table></figure>

<p>进入redis 客户端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 16380</span><br></pre></td></tr></table></figure>

<p>在 redis 客户端里通过命令查看哨兵节点的状态信息，能看到如下结果</p>
<p><img src="https://i0.hdslb.com/bfs/album/79f94684b4e37755d64c48e91011972065aab11a.png" alt="image-20221125095844340"></p>
<p>该哨兵节点正在监控 172.17.0.2:6379 指向的主服务器，再观察 sentinels 的值是2，表示 172.17.0.2:6379 指向的服务器（redis-master主服务器）被两台哨兵节点监控。</p>
<p>至此，完成了哨兵节点监控”一主二从“的集群，该集群的架构如图所示。在实际项目里，可以通过配置让哨兵节点监控多个集群。</p>
<img src="https://i0.hdslb.com/bfs/album/b10f25b0295759d0233463d603123a703d5a71ee.png" alt="image-20221125100606552" style="zoom:67%;" />

<h3 id="2-2哨兵节点的常用配置"><a href="#2-2哨兵节点的常用配置" class="headerlink" title="2.2哨兵节点的常用配置"></a>2.2哨兵节点的常用配置</h3><p>在上文里，通过 <code>sentinel monitor master 172.17.0.2 6379 2</code> 配置参数来设置该节点所监控的主机，此外还可以通过 <code>sentinel down-after-milliseconds</code> 参数来指定判断下线时间的阈值，下面给出一个具体的用法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel down-after-milliseconds master 60000</span><br></pre></td></tr></table></figure>

<p>其中，master 表示该哨兵节点监控的服务器名，需要和sentinel monitor 配置项里指定的服务器名保持一致，而60000表示时间，单位是毫秒。也就是说，如果在60秒里该哨兵节点没有收到master服务器的正确响应，就会认为该服务器已经下线失效</p>
<p>只有当2个哨兵节点（ <code>sentinel monitor master 172.17.0.2 6379 2</code> 中2就是这个作用）都通过”sentinel down-after-milliseconds”判断该服务器失效时才会认定该服务器失效，从而启动故障恢复机制。</p>
<p>此外，还可以通过如下配置来设置”故障恢复的时效“，该时效参数的单位是 毫秒，这里的含义是，在进行故障恢复时，如果在180秒里还没有完成主从服务器的切换，就会认定本次恢复动作失败。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel failover-timeout master 180000</span><br></pre></td></tr></table></figure>



<h3 id="2-3哨兵模式下的故障自动恢复"><a href="#2-3哨兵模式下的故障自动恢复" class="headerlink" title="2.3哨兵模式下的故障自动恢复"></a>2.3哨兵模式下的故障自动恢复</h3><p>通过上文的配置，能实现用哨兵节点监控主从复制模式里主服务器的效果。</p>
<p>这里将演示主服务器失效后故障自动恢复的效果：</p>
<p>到 redis-master 这个 Docker 容器所在的命令窗口里，用 exit 命令退出 Docker 容器，并停止该容器里的 Redis 服务器，以此来模拟主服务器失效的效果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop redis-master</span><br></pre></td></tr></table></figure>

<img src="https://i0.hdslb.com/bfs/album/1194ef0f941058684ccc451926001e84f933387f.png" alt="image-20221125112303803" style="zoom:80%;" />

<p>在 redis-sentinel1 这个哨兵节点所在的命令行窗口，通过 <code>info sentinel</code> 命令观察该哨兵节点所监控的主从集群状态，能看到如下的效果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info sentinel</span><br></pre></td></tr></table></figure>

<p>因为哨兵节点有默认的等待时间，所以需要等待一段时间</p>
<img src="https://i0.hdslb.com/bfs/album/8f6a69221e950e2f2551f3f74df0a62cf18e45f4.png" alt="image-20221125112406484" style="zoom:80%;" />

<p>切换到 <code>172.17.0.3:6380</code> （redis-slave1）对应的命令窗体，运行命令，能看到如下部分结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info replication</span><br></pre></td></tr></table></figure>

<img src="https://i0.hdslb.com/bfs/album/6e72560a33706f15e7a1c07d491833b498394d56.png" alt="image-20221125113312594" style="zoom:80%;" />

<h3 id="2-4通过日志观察故障恢复流程"><a href="#2-4通过日志观察故障恢复流程" class="headerlink" title="2.4通过日志观察故障恢复流程"></a>2.4通过日志观察故障恢复流程</h3><p>由于在启动redis-sentinel1和redis-sentinel2节点时指定了日志的路径和位置，这里可以在对应的Docker容器里通过日志观察具体的故障恢复流程。</p>
<p>日志里有sdown的字样，sdown的含义是“主观下线”，与之对应的有表示客观下线的odown。</p>
<p>当本哨兵节点发现所监控的master服务器下线后，会先把它标记为”主观下线”，当多个哨兵节点（根据设置，这里需要是2个）都判断该服务器下线后，把该服务器标志成“客观下线”。</p>
<p>当检测到客观下线后，启动故障恢复（failover)流程，完成故障恢复后，会如第19行日志所示，切换主服务器，切换完成后，加载从服务器。至此，完成了故障自动恢复的流程。</p>
<p>只能由一个哨兵节点完成故障自动恢复的动作，因此如果有多个哨兵节点同时监控到主服务器失效，那么最终只能有一个哨兵节点通过竞争得到故障恢复的权力。</p>
<img src="https://i0.hdslb.com/bfs/album/be3fa9e4e81ee7e2c9f82ba1a318d163bb883ae6.png" alt="image-20221125113721883" style="zoom:80%;" />

<h3 id="2-5故障节点恢复后的表现"><a href="#2-5故障节点恢复后的表现" class="headerlink" title="2.5故障节点恢复后的表现"></a>2.5故障节点恢复后的表现</h3><p>在 redis-master 所在的窗口重新启动redis服务器，以此来模拟该服务器排除故障后的效果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start redis-master</span><br></pre></td></tr></table></figure>

<p>运行完命令后，再到 redis-slave1 所在的命令窗口里运行 <code>info replication</code> 命令，就能看到如下的输出，从输出里能确认故障恢复后的 redis-master 服务器会自动以 ”从服务器”的身份接入</p>
<img src="https://i0.hdslb.com/bfs/album/16ca665c22b6441d922a004ea93d43c3051d9c9f.png" alt="image-20221125114122264" style="zoom:80%;" />

<p>哨兵节点不仅能自动恢复故障，而且当故障节点恢复后会自动把她重新加入到集群中，而无须人工干预。也就是说，与简单的“主从复制模式集群”相比，基于哨兵模式的集群能很好地提升系统地可靠性。</p>
<h2 id="3-cluster集群"><a href="#3-cluster集群" class="headerlink" title="3.cluster集群"></a>3.cluster集群</h2><h3 id="3-1-搭建cluster集群"><a href="#3-1-搭建cluster集群" class="headerlink" title="3.1 搭建cluster集群"></a>3.1 搭建cluster集群</h3><p>这里将通过如下步骤搭建 “三主三从” 的 cluster集群，由此大家能进一步理解 cluster集群。其他类型的 cluster集群，比如包含 4个主节点，或者每个主节点里再带2个从节点，可以照此步骤搭建。</p>
<p>在 <code>/opt/server</code> 目录里，新建名为 <code>cluster-m1.conf</code> 的配置文件，该配置文件用于配置 cluster 集群中的一个主节点，具体配置文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6379 # 指定该redis服务器的端口为6379</span><br><span class="line">dir /redisConfig # 节点的日志路径</span><br><span class="line">logfile cluster-m1.log  # 节点的日志文件名</span><br><span class="line">cluster-enabled yes # 开启cluster集群模式，并把该节点加入集群</span><br><span class="line">cluster-config-file nodes-6379.conf  # 设置了该节点cluster集群相关的配置文件，该文件会自动生成</span><br></pre></td></tr></table></figure>

<p>依照上述配置文件，为第二个主节点创建名为 <code>cluster-m2.conf</code> 的配置文件，具体配置文件内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br><span class="line">dir /redisConfig</span><br><span class="line">logfile cluster-m2.log</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6380.conf</span><br></pre></td></tr></table></figure>

<p>以同样的方式配置 <code>cluster-m3.conf</code> ，将 port 设为 6381</p>
<img src="https://i0.hdslb.com/bfs/album/8555a1d14c58f3404140b296dff0ba3fd9c6b5dd.png" alt="image-20221125120921274" style="zoom: 80%;" />

<p>然后创建 <code>cluster-s1.conf</code> 配置文件，用以配置第一个从节点，在其中编写如下内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 16379</span><br><span class="line">dir /redisConfig</span><br><span class="line">logfile cluster-s1.log</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-16379.conf</span><br></pre></td></tr></table></figure>

<p>在配置文件里并没有设置主从关系，主从关系将在后续的步骤里设置。</p>
<p>根据 <code>cluster-s1.conf</code> 配置文件，再分别创建 <code>cluster-s2.conf</code> 、<code>cluster-s3.conf</code> ，对应端口分别为 16380、16381</p>
<img src="https://i0.hdslb.com/bfs/album/4249c37c620759947f87e8793632625fdb4d4491.png" alt="image-20221125121313067" style="zoom: 80%;" />



<p>在完成编写上述配置文件的基础上，打开一个命令窗口，在其中运行如下的docker命令。创建名为 redis-m1 的docker容器，并在其中通过 redis-server 命令启动容器中的 redis 服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-m1 -v /opt/server:/redisConfig -p 6379:6379 redis:6.2.7 redis-server /redisConfig/cluster-m1.conf</span><br></pre></td></tr></table></figure>

<p>由于在通过 redis-server 命令启动 redis 服务器时传入了 cluster-m1.conf 配置文件，因此该容器里的 redis 会自动加入cluster集群，当然现在集群中只有者一个节点。</p>
<p>由于在 cluster-m1.conf 配置文件里指定了 cluster集群相关的配置文件是 node-6379.conf，因此在启动时会自动生成该文件，此时在与容器里 &#x2F;redisConfig 映射的 &#x2F;opt&#x2F;server 目录中就能看到生成的 node-6379.conf 文件</p>
<img src="https://i0.hdslb.com/bfs/album/9e36fddb8cacfc11b4a7135926b13f25297ff207.png" alt="image-20221125122146050" style="zoom:80%;" />



<p>随后开启2个新的窗口，分别启动cluster集群中的第二个和第三个节点。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-m2 -v /opt/server:/redisConfig -p 6380:6380 redis:6.2.7 redis-server /redisConfig/cluster-m2.conf</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-m3 -v /opt/server:/redisConfig -p 6381:6381 redis:6.2.7 redis-server /redisConfig/cluster-m3.conf</span><br></pre></td></tr></table></figure>

<p>以此类推，再新建3个命令窗口，在这3个命令窗口分别运行 docker run 命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-s1 -v /opt/server:/redisConfig -p 16379:16379 redis:6.2.7 redis-server /redisConfig/cluster-s1.conf</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-s2 -v /opt/server:/redisConfig -p 16380:16380 redis:6.2.7 redis-server /redisConfig/cluster-s2.conf</span><br><span class="line"></span><br><span class="line">docker run -itd --name redis-s3 -v /opt/server:/redisConfig -p 16381:16381 redis:6.2.7 redis-server /redisConfig/cluster-s3.conf</span><br></pre></td></tr></table></figure>

<p>运行完上述命令后，可以在任意一个开启着的命令窗口运行 <code>docker ps</code> ，确认上述 Redis 服务均已启动</p>
<img src="https://i0.hdslb.com/bfs/album/f23006c7d306ee44eaa892ae4615c8593b214d3c.png" alt="image-20221125122824760" style="zoom:80%;" />

<p>由于这里是在一台主机上通过不同的Docker实例来启动多个Redis服务，因此用不同的端口号来区分每个Redis服务。在真实项目里，不同的Redis服务一般是安装在不同服务器上的，所以可以用IP地址来区分不同的Redis服务，而它们所用的端口可以都是6379。</p>
<p>此时打开描述redis-m1节点集群连接配置的nodes-6379.conf文件，就会看到如下的内容：</p>
<img src="https://i0.hdslb.com/bfs/album/e5c8642a2bd3e225601df982cb889e3e694da919.png" alt="image-20221125123048446" style="zoom:80%;" />

<p>从第1行的输出里能看到该节点属于master (主)节点，它只连接到myself自身，没有同其他Redis节点关联。观察nodes-6380.conf等配置文件，也会发现当前这些节点均没有关联其他节点，在后继的步骤里，将用 <code>meet命令</code> 关联各节点。</p>
<p>先通过 <code>docker inspect redis-m1</code> 等命令查看上述各节点所在的IP地址，这其实也是诸多Redis服务器的IP地址。大家在自己电脑上实践的时候用dokcer run命令所创建的Redis服务器IP地址未必和本教程一致，如果有不一致的，就需要对应地修改下文给出的meet命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect redis-m1 | grep IPAddress</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">节点名称</th>
<th align="center">IP地址</th>
<th align="center">端口</th>
</tr>
</thead>
<tbody><tr>
<td align="center">redis-m1</td>
<td align="center">172.17.0.2</td>
<td align="center">6379</td>
</tr>
<tr>
<td align="center">redis-m2</td>
<td align="center">172.17.0.3</td>
<td align="center">6380</td>
</tr>
<tr>
<td align="center">redis-m3</td>
<td align="center">172.17.0.4</td>
<td align="center">6381</td>
</tr>
<tr>
<td align="center">redis-s1</td>
<td align="center">172.17.0.5</td>
<td align="center">16379</td>
</tr>
<tr>
<td align="center">redis-s2</td>
<td align="center">172.17.0.6</td>
<td align="center">16380</td>
</tr>
<tr>
<td align="center">redis-s3</td>
<td align="center">172.17.0.7</td>
<td align="center">16381</td>
</tr>
</tbody></table>
<p>在得到所有 Redis 容器的 IP地址后，回到 redis-m1 容器所在的命令窗口，进入容器内</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-m1 bash</span><br></pre></td></tr></table></figure>

<p>在其中用如下的命令连接该节点和其他节点。注意，这里的 IP地址 是 docker 容器工作的 IP地址，而不是 127.0.0.1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 6379 cluster meet 172.17.0.3 6380</span><br><span class="line">redis-cli -p 6379 cluster meet 172.17.0.4 6381</span><br><span class="line">redis-cli -p 6379 cluster meet 172.17.0.5 16379</span><br><span class="line">redis-cli -p 6379 cluster meet 172.17.0.6 16380</span><br><span class="line">redis-cli -p 6379 cluster meet 172.17.0.7 16381</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 cluster meet 命令连接各个节点</span></span><br></pre></td></tr></table></figure>

<p>运行完成之后，进入 redis-m1 服务器内，再运行命令，就能看到如下所示的部分结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster info</span><br></pre></td></tr></table></figure>

<img src="https://i0.hdslb.com/bfs/album/654c132ed50f8f629153113f948cde94112f2b5d.png" alt="image-20221125125153579" style="zoom:80%;" />

<p>输出里能看到当前 cluster 集群里有6个节点，集群处于 fail（失败）状态，原因是还没有给集群中的每个节点分配哈希槽，在后续步骤里将执行分配哈希槽的相关操作。</p>
<p>为三个主节点分配哈希槽。分配哈希槽的命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 172.17.0.2 -p 6379 cluster addslots n</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-h和-p指向Redis服务器节点，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 cluster addslots 命令添加哈希槽，其中 n 是哈希槽的编号</span></span><br></pre></td></tr></table></figure>

<p>根据上面的描述，需要把0到5460号哈希槽分配到 redis-m1 节点上，如果要运行命令则需要运行5000多次，所以用如下名为 <code>setHashSlots.sh</code> 的脚本来分配，该脚本也是放在 <code>/opt/server</code> 目录里，以便各 docker 容器能映射到。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /opt/server/setHashSlots.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">for i in $(seq 0 5460)</span><br><span class="line">do</span><br><span class="line">/usr/local/bin/redis-cli -h 172.17.0.2 -p 6379 cluster addslots $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash /redisConfig/setHashSlots.sh</span><br></pre></td></tr></table></figure>

<p>随后更改 setHashSlots.sh 脚本里的哈希槽值和端口，到 redis-m2 所在的窗口里运行，为该节点分配 5461到10922号哈希槽。&#x3D;&#x3D;注意节点工作在6380端口，所以下面第3行 <code>-p</code> 后的值是 6380&#x3D;&#x3D;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">for i in $(seq 5461 10922)</span><br><span class="line">do</span><br><span class="line">/usr/local/bin/redis-cli -h 172.17.0.3 -p 6380 cluster addslots $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>再次更改 setHashSlots.sh 脚本里的哈希槽值和端口，到 redis-m3 所在的窗口里运行，为该节点分配 10923 到 16383号哈希槽。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">for i in $(seq 10923 16383)</span><br><span class="line">do</span><br><span class="line">/usr/local/bin/redis-cli -h 172.17.0.4 -p 6381 cluster addslots $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>运行完成后，就可以把16384各哈希槽分配到3各主节点上了</p>
<div class="note danger simple"><p>错误提示说：slot 插槽被占用，，，，，，，</p>
<img src="https://i0.hdslb.com/bfs/album/5d4136be21a91329999350f827485c1b4a339ed8.png" alt="image-20221125141836989" style="zoom: 80%;" />

<p>这是因为 搭建集群时，以前 redis 的旧数据和配置信息没有清理干净。</p>
<p>解决方案：</p>
<ul>
<li>用 redis-cli 登录到每个节点执行 <code>flushall</code> 和 <code>cluster reset</code> 就可以了</li>
</ul>
<img src="https://i0.hdslb.com/bfs/album/de7dcc2d5bd88cb207ead878d3a49ca86da5b0f3.png" alt="image-20221125142028242" style="zoom: 80%;" />
</div>



<p>回到 redis-m1 所在的窗口，用 redis-cli 进入客户端后，再运行命令查看当前 cluster 集群的情况，能看到有如下的部分输出结果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster info</span><br></pre></td></tr></table></figure>

<img src="https://i0.hdslb.com/bfs/album/89baea729b75d792a31d4ae4f76c7d279ee74084.png" alt="image-20221125143305376" style="zoom:80%;" />

<p>cluster_state:ok 确认该cluster集群工作正常，cluster_slots_assigned 与 cluster_slots_ok 确认 16384个哈希槽已经被分配到该 cluster 集群中。cluster_konwn_nodes 能确认当前 cluster 集群中有6个节点。</p>
<p>把cluster集群中的3个节点设置为“从”节点。设置从节点的方式是用 redis-cli 命令进入节点 redis 服务器，并运行 <code>cluster replicate &lt;对应主节点的node-id&gt;</code> 。</p>
<p>这里涉及一个问题：如何查看主节点的 node-id？回到 redis-m1 所在的命令行窗口，用 redis-cli 连接到服务器，再运行 <code>cluster nodes</code> 命令，虽然还没有设置主从关系，但是各节点已经互联，所以可以从运行结果里看到各节点的 node-id，相关操作如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<img src="https://i0.hdslb.com/bfs/album/afebbe5e9c63fbc42169af1236bfb9c48109a4ba.png" alt="image-20221125143944782" style="zoom:80%;" />

<p>从输出可以看出，<code>172.17.0.3:6380</code> 对应节点的 node-id 是 51e3……以此类推</p>
<p>得到各 node-id 后，可以进入 redis-s1 对应的命令行窗口，再通过命令进入该容器的命令行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-s1 /bin/bash</span><br><span class="line">redis-cli -p 16379</span><br></pre></td></tr></table></figure>

<p>随后设置主从关系，具体命令如下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate 284dadf30b64fd5b8e8015d9d3a14b982a4d2ed8</span><br></pre></td></tr></table></figure>

<p><code>cluster replicate</code> 命令后面跟随的参数是 172.17.0.2:6379 对应的 node-id，由此可以把 redis-s1 这个节点设置为 redis-m1 的从节点。进入 redis-s2 所在的命令行窗口，将 redis-s2 设置为 redis-m2的从节点</p>
<img src="https://i0.hdslb.com/bfs/album/99d70cb846288c3de03d8aebec5f7f4c41fd693f.png" alt="image-20221125152539883" style="zoom:80%;" />

<h3 id="3-2-在cluster集群中读写数据"><a href="#3-2-在cluster集群中读写数据" class="headerlink" title="3.2 在cluster集群中读写数据"></a>3.2 在cluster集群中读写数据</h3><p>先用 <code>redis-cli -p 16381</code> 命令接入 redis-s3 所在的服务器，此时输入 set 命令，就能看到如下的错误提示信息</p>
<img src="https://i0.hdslb.com/bfs/album/bd2e2980d763cb8224b6312ddb3b2e563af94df6.png" alt="image-20221125153856259" style="zoom:80%;" />

<p>根据之前描述的cluster集群的知识，在 set命令 时会先对键（name）进行 CRC16 运算，再根据结果把这个键放入对应的哈希槽所在的节点，从输出的错误信息可以看到，这个name键应该放入<code>172.17.0.3:6380</code> 哈希槽中</p>
<p>在实际操作中，用户希望是透明地进行数据的读写操作，而不希望看到此类的读写错误。</p>
<p>为了达到这个效果，需要在 redis-cli 命令后加入 -c 参数，以实现互联的效果，具体的命令及运行结果如下所示</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 16381 -c</span><br></pre></td></tr></table></figure>

<img src="https://i0.hdslb.com/bfs/album/0d6cc2b98425940f89400adf98bc2701310fa475.png" alt="image-20221125154119117" style="zoom:80%;" />

<p><code>redis-cli 命令</code> 后带了 -c 参数，所以当执行set命令时，虽然不该把name键放入本结点对应的哈希槽里，但是在cluster集群中的Redis服务器会自动把数据重新定位到 172.17.0.3:6380节点上。</p>
<p>同样使用 <code>get命令</code>时，虽然 name 键对应的数据没有存在该节点上，但可以读到name键对应的数据。这种“自动定位”带来的“读写透明”效果正是开发所需要的。</p>
<img src="https://i0.hdslb.com/bfs/album/8c09aa82bbf5ce04a6d9e7c9dfa247e221d187d0.png" alt="image-20221125154215381" style="zoom:80%;" />

<p>如果将 redis-m2 节点暂停掉，然后用set命令设置键为name的数据，就会发现改建会被设置到其他节点上。也就是说，<strong>当节点失效后，cluster集群会自动再分配哈希槽，从而实现故障自动修复的效果</strong></p>
<h3 id="3-3-模拟扩容和数据迁移动作"><a href="#3-3-模拟扩容和数据迁移动作" class="headerlink" title="3.3 模拟扩容和数据迁移动作"></a>3.3 模拟扩容和数据迁移动作</h3><p>在上文的“三主三从”的cluster集群里，针对键的读写操作将会均摊到三个主节点上，比如当前针对Redis缓存的并发量是每秒 3000 次访问，那么均摊到三台主节点上的访问请求也就每秒1000次，也就是说cluster集群能很好地应对高并发带来的挑战。</p>
<p>随着项目业务量的增加，对cluster集群的访问压力有可能会增大，此时就需要通过向cluster集群里新增节点来承受更大的并发量。通过如下步骤，将会向上述搭建的“三主三从”的cluster集群里再增加一个主节点和一个从节点，以此实现扩容的效果。</p>
<p>在 <code>opt/server</code> 目录里，新增 cluster-mnew.conf 配置文件，用以配置新增主节点的信息，代码如下所示。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 6385</span><br><span class="line">dir /redisConfig</span><br><span class="line">logfile cluster-mnew.log</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-6385.conf</span><br></pre></td></tr></table></figure>

<p>随后用 <code>docker run 命令</code> 启动该容器以及其中的Redis 服务器</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-mnew -v /opt/server:/redisConfig -p 6385:6385 redis:6.2.7 redis-server /redisConfig/cluster-mnew.conf</span><br></pre></td></tr></table></figure>

<p>启动后再执行 <code>docker inspect redis-mnew</code> 命令查看该Redis 服务器节点的 IP地址：172.17.0.8</p>
<img src="https://i0.hdslb.com/bfs/album/12e27370bb90151ccfdf68fe42bfae8d925b0ab1.png" alt="image-20221125162106462" style="zoom:80%;" />

<p>在 <code>/opt/server</code> 目录里，新增 cluster-snew.conf 配置文件，用以配置新增从节点（将使用16385端口）的信息，配置文件如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">port 16385</span><br><span class="line">dir /redisConfig</span><br><span class="line">logfile cluster-snew.log</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-16385.conf</span><br></pre></td></tr></table></figure>

<p>随后用如下的docker命令启动该容器以及其中的Redis服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name redis-snew -v /opt/server:/redisConfig -p 16385:16385 redis:6.2.7 redis-server /redisConfig/cluster-snew.conf</span><br></pre></td></tr></table></figure>

<p>启动后再执行 <code>docker inspect redis-snew</code> 命令查看该Redis 服务器节点的 IP地址：172.17.0.9</p>
<img src="https://i0.hdslb.com/bfs/album/410cd123ff63b74dc03e02c8e7e288f2035af15d.png" alt="image-20221125162210262" style="zoom:80%;" />

<p>&#x3D;&#x3D;这里请注意，&#x3D;&#x3D;在cluster集群模式里不能通过slaveof的方式设置主从模式，所以需要先把节点加入cluster集群，再通过命令来设置主从关系。</p>
<p>通过 redis-cli 命令，进入 redis-m1 节点所对应的 Redis 服务器，再通过如下的两条命令把上述两个节点加入cluster集群</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cluster meet 172.17.0.8 6385</span><br><span class="line">cluster meet 172.17.0.9 16385</span><br></pre></td></tr></table></figure>

<p>通过 <code>cluster nodes</code> 查看节点ID</p>
<img src="https://i0.hdslb.com/bfs/album/b93dd3640734308bf2e7d0e1e3b9ecaced3c3327.png" alt="image-20221125170614859" style="zoom:80%;" />

<div class="note info simple"><p>执行 <code>cluster nodes</code> 命令后，发现新加入的节点是从节点，如下图</p>
<img src="https://i0.hdslb.com/bfs/album/fc52f5ce534de598024920c1914e87cac4bce244.png" alt="image-20221125162530959" style="zoom:80%;" />

<p>通过 redis-cli 进入redis-mnew 和 redis-snew命令窗体，执行 <code>cluster reset</code> 命令，重置节点</p>
</div>

<p>用 redis-cli 命令进入 <strong>redis-snew节点</strong>对应的 Redis服务器，设置主从关系</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-snew /bin/bash</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster replicate 55696860a746028bc0f0d3ff08a0eefaf3cad028</span><br></pre></td></tr></table></figure>

<p>cluster replicate 命令后跟的参数是 redis-mnew 节点对应的 node-id。</p>
<p>通过上述步骤，确实能把两个节点加入cluster集群中，但是没有分配哈希槽，所以这2个节点还无法真正地承载缓存数据。此时进入 <strong>redis-mnew 容器</strong>对应的命令行窗口，通过如下命令可以给 redis-mnew 节点分配哈希槽</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it redis-mnew /bin/bash</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 172.17.0.2:6379 --cluster-from node-ID1,node-ID2,node-ID3 --cluster-to node-mn --cluster-slots 1024</span><br></pre></td></tr></table></figure>

<p>其中，reshard 后面的参数表示由这个redis服务器执行重新分配哈希槽的命令，–cluster-from 后面跟随的参数是原来3个主节点的node-id，即分配哈希槽的源节点，–cluster-to后面跟随的参数表示目标节点， –cluster-slots后面跟随的参数表示分配哈希槽的数量。</p>
<p>上述命令执行后会从原来三个主节点里各取1024个哈希槽分配到redis-mnew节点上，从而使该节点也能用哈希槽存放对应的键。</p>
<p>至此，完成了扩容动作。如果此时运行 <code>cluster info</code> 命令，就能看到如下所示的部分输出结果</p>
<img src="https://i0.hdslb.com/bfs/album/1550910eff6eea395fd7b8dc8972e558bd212490.png" alt="image-20221125183004851" style="zoom:80%;" />

<p>cluster 集群中共有8个节点，“四主四从”结构</p>
<div class="note danger simple"><p>错误提示：[WARNING] Node 172.17.0.2:6379 has slots in importing state 5798.</p>
<img src="https://i0.hdslb.com/bfs/album/7e06920d38f0df7d92ceabb4a4e952ae3a623889.png" alt="image-20221125182848887" style="zoom:80%;" />

<p>解决方案：分别去对应的端口命令串口，执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster setslot 5798 stable</span><br></pre></td></tr></table></figure>

<img src="https://i0.hdslb.com/bfs/album/aad67b69266cf18ac0b8ed7ff02d45191c33343e.png" alt="image-20221125183306696" style="zoom:80%;" />
</div>

<p>在扩容时请&#x3D;&#x3D;注意&#x3D;&#x3D;，在迁移哈希槽以及其中的数据这段时间内，这部风数据是不可用的，由此可能出现缓存失效的现象，所以建议一般在业务请求比较空闲时进行扩容动作，比如将扩容的时间放在周末的凌晨。</p>
<p>在扩容时，不必精确地让cluster集群里地主节点包含相同数量地哈希槽，有些误差是可以接收地，而且如果cluster集群中某个服务器地性能较好，还可以在其中适当多分配些哈希槽，从而进一步提升cluster集群地吞吐量。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://linkasage.github.io">LinkaSage</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://linkasage.github.io/posts/505826b8.html">https://linkasage.github.io/posts/505826b8.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://linkasage.github.io" target="_blank">LinkaSage' Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/Redis%E8%BF%9B%E9%98%B6/">Redis进阶</a></div><div class="post_share"><div class="social-share" data-image="https://wwww.lvmoo.com/1195.love/3398019585_hudf00fdeabc994d23ae3b1aa2b480a234_181774_1024x0_resize_q75_box.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/db4d2069.html" title="Redis高级"><img class="cover" src="https://wwww.lvmoo.com/1195.love/3398019585.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Redis高级</div></div></a></div><div class="next-post pull-right"><a href="/posts/1d3045f4.html" title="Redis初级"><img class="cover" src="https://upload.wikimedia.org/wikipedia/en/thumb/6/6b/Redis_Logo.svg/1200px-Redis_Logo.svg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis初级</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/1d3045f4.html" title="Redis初级"><img class="cover" src="https://upload.wikimedia.org/wikipedia/en/thumb/6/6b/Redis_Logo.svg/1200px-Redis_Logo.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-23</div><div class="title">Redis初级</div></div></a></div><div><a href="/posts/db4d2069.html" title="Redis高级"><img class="cover" src="https://wwww.lvmoo.com/1195.love/3398019585.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-18</div><div class="title">Redis高级</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/weichao-here/ChartBed/img/istj-logistician-s3-v1-male.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LinkaSage</div><div class="author-info__description">记录自己的成长，分享自己的所得</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LinkaSage"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-AOF%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.</span> <span class="toc-text">1. AOF持久化实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">1.修改配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8-redis"><span class="toc-number">1.2.</span> <span class="toc-text">2.重新启动 redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C-redis"><span class="toc-number">1.3.</span> <span class="toc-text">3.操作 redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D"><span class="toc-number">1.4.</span> <span class="toc-text">4.模拟数据恢复</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%9E%E8%B7%B5"><span class="toc-number">2.</span> <span class="toc-text">2. RDB 持久化实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1"><span class="toc-number">2.1.</span> <span class="toc-text">1.修改配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8-redis-1"><span class="toc-number">2.2.</span> <span class="toc-text">2.重新启动 redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9Credis"><span class="toc-number">2.3.</span> <span class="toc-text">3.操作redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%94%A8%E5%BF%AB%E7%85%A7%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE"><span class="toc-number">2.4.</span> <span class="toc-text">4.用快照文件恢复数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8-docker-%E5%AE%89%E8%A3%85-redis"><span class="toc-number">3.</span> <span class="toc-text">3. 使用 docker 安装 redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%BF%90%E8%A1%8C-Redis-%E5%AE%B9%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 运行 Redis 容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%9F%A5%E7%9C%8B%E5%90%AF%E5%8A%A8%E6%97%A5%E5%BF%97"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 查看启动日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E8%BF%9B%E5%85%A5Redis%E5%AE%B9%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 进入Redis容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E9%80%80%E5%87%BA-Redis-%E5%AE%B9%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 退出 Redis 容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%90%AF%E5%8A%A8%E6%97%B6%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 启动时加载配置文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Redis%E9%9B%86%E7%BE%A4"><span class="toc-number">4.</span> <span class="toc-text">4. Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4"><span class="toc-number">4.1.</span> <span class="toc-text">1.主从复制模式集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%94%A8%E5%91%BD%E4%BB%A4%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 用命令搭建主从集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 通过配置搭建主从集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E9%85%8D%E7%BD%AE%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%95%88%E6%9E%9C"><span class="toc-number">4.1.3.</span> <span class="toc-text">1.3 配置读写分离效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E7%94%A8%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E6%8F%90%E9%AB%98%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">4.1.4.</span> <span class="toc-text">1.4 用心跳机制提高主从复制的可靠性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4"><span class="toc-number">4.2.</span> <span class="toc-text">2.哨兵模式集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E6%90%AD%E5%BB%BA%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4"><span class="toc-number">4.2.1.</span> <span class="toc-text">2.1搭建哨兵模式集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E5%93%A8%E5%85%B5%E8%8A%82%E7%82%B9%E7%9A%84%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.2哨兵节点的常用配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E6%95%85%E9%9A%9C%E8%87%AA%E5%8A%A8%E6%81%A2%E5%A4%8D"><span class="toc-number">4.2.3.</span> <span class="toc-text">2.3哨兵模式下的故障自动恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E9%80%9A%E8%BF%87%E6%97%A5%E5%BF%97%E8%A7%82%E5%AF%9F%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">4.2.4.</span> <span class="toc-text">2.4通过日志观察故障恢复流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E6%95%85%E9%9A%9C%E8%8A%82%E7%82%B9%E6%81%A2%E5%A4%8D%E5%90%8E%E7%9A%84%E8%A1%A8%E7%8E%B0"><span class="toc-number">4.2.5.</span> <span class="toc-text">2.5故障节点恢复后的表现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-cluster%E9%9B%86%E7%BE%A4"><span class="toc-number">4.3.</span> <span class="toc-text">3.cluster集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%90%AD%E5%BB%BAcluster%E9%9B%86%E7%BE%A4"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 搭建cluster集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%9C%A8cluster%E9%9B%86%E7%BE%A4%E4%B8%AD%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">4.3.2.</span> <span class="toc-text">3.2 在cluster集群中读写数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%A8%A1%E6%8B%9F%E6%89%A9%E5%AE%B9%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E5%8A%A8%E4%BD%9C"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.3 模拟扩容和数据迁移动作</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/125dfa57.html" title="git学会这些就够了"><img src="https://cdn.sanity.io/images/hvk0tap5/production/f41e4d86f6d0134e519c8fa1a16cfb7ab34cb047-1920x1080.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="git学会这些就够了"/></a><div class="content"><a class="title" href="/posts/125dfa57.html" title="git学会这些就够了">git学会这些就够了</a><time datetime="2024-05-25T03:06:54.000Z" title="发表于 2024-05-25 11:06:54">2024-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/53f1b0f5.html" title="CDN学习"><img src="https://tezhost.com/wp-content/uploads/2023/06/What-Is-CDN-And-How-Does-It-Work.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CDN学习"/></a><div class="content"><a class="title" href="/posts/53f1b0f5.html" title="CDN学习">CDN学习</a><time datetime="2024-03-15T14:24:39.000Z" title="发表于 2024-03-15 22:24:39">2024-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/598b5c3.html" title="Nginx性能优化"><img src="https://cdn.jsdelivr.net/gh/weichao-here/ChartBed/img/image-20240320225159016.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx性能优化"/></a><div class="content"><a class="title" href="/posts/598b5c3.html" title="Nginx性能优化">Nginx性能优化</a><time datetime="2023-10-20T14:12:45.000Z" title="发表于 2023-10-20 22:12:45">2023-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a4c75e30.html" title="Nginx场景实战"><img src="https://oss.muzing.top/image/Nginx_%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Nginx场景实战"/></a><div class="content"><a class="title" href="/posts/a4c75e30.html" title="Nginx场景实战">Nginx场景实战</a><time datetime="2023-06-20T14:12:33.000Z" title="发表于 2023-06-20 22:12:33">2023-06-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4a33540b.html" title="Spring Boot异步处理"><img src="https://img-blog.csdnimg.cn/img_convert/56add39f935cac5733d29cef3cb9e4d0.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Boot异步处理"/></a><div class="content"><a class="title" href="/posts/4a33540b.html" title="Spring Boot异步处理">Spring Boot异步处理</a><time datetime="2023-04-17T10:24:39.000Z" title="发表于 2023-04-17 18:24:39">2023-04-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LinkaSage</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>